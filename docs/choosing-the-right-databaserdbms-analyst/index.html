<!doctype html>
<html>
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    a {
	word-wrap: break-word !important;
}
  </style>
  
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/default.min.css">
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/highlight.min.js"></script>

<!-- and it's easy to individually load additional languages -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/languages/python.min.js"></script>

<link rel="stylesheet" href="/post.css"> 

</head>
<body class="bg-gray-50">

<nav class="bg-white border-gray-200 dark:bg-gray-900">
    <div class="max-w-screen-xl flex flex-wrap items-center justify-between mx-auto p-4">
      <a href="/" class="flex items-center">
          <img src="https://www.pythonkitchen.com/wp-content/uploads/2022/11/cropped-p3-50x50.png" class="h-8 mr-3" alt="PythonKitchen Logo" />
          <span class="self-center text-2xl font-semibold whitespace-nowrap dark:text-white">PythonKitchen</span>
      </a>
      <button data-collapse-toggle="navbar-default" type="button" class="inline-flex items-center p-2 w-10 h-10 justify-center text-sm text-gray-500 rounded-lg md:hidden hover:bg-gray-100 focus:outline-none focus:ring-2 focus:ring-gray-200 dark:text-gray-400 dark:hover:bg-gray-700 dark:focus:ring-gray-600" aria-controls="navbar-default" aria-expanded="false">
          <span class="sr-only">Open main menu</span>
          <svg class="w-5 h-5" aria-hidden="true" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 17 14">
              <path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M1 1h15M1 7h15M1 13h15"/>
          </svg>
      </button>
      <div class="hidden w-full md:block md:w-auto" id="navbar-default">
        <ul class="font-medium flex flex-col p-4 md:p-0 mt-4 border border-gray-100 rounded-lg bg-gray-50 md:flex-row md:space-x-8 md:mt-0 md:border-0 md:bg-white dark:bg-gray-800 md:dark:bg-gray-900 dark:border-gray-700">
          <li>
            <a href="/" 
            class="block py-2 pl-3 pr-4 text-white bg-blue-700 rounded md:bg-transparent md:text-blue-700 md:p-0 dark:text-white md:dark:text-blue-500" aria-current="page">
            Home</a>
          </li>
          <li>
            <a href="https://github.com/pythonkitchen/pythonkitchen/tree/source/data/posts" class="block py-2 pl-3 pr-4 text-gray-900 rounded hover:bg-gray-100 md:hover:bg-transparent md:border-0 md:hover:text-blue-700 md:p-0 dark:text-white md:dark:hover:text-blue-500 dark:hover:bg-gray-700 dark:hover:text-white md:dark:hover:bg-transparent">
              Write</a>
          </li>
          <li>
            <a href="https://forms.gle/gf1p1Aitw9M9m8Zy5" class="block py-2 pl-3 pr-4 text-gray-900 rounded hover:bg-gray-100 md:hover:bg-transparent md:border-0 md:hover:text-blue-700 md:p-0 dark:text-white md:dark:hover:text-blue-500 dark:hover:bg-gray-700 dark:hover:text-white md:dark:hover:bg-transparent">
              Contact</a>
          </li>
          <!-- <li>
            <a href="#" class="block py-2 pl-3 pr-4 text-gray-900 rounded hover:bg-gray-100 md:hover:bg-transparent md:border-0 md:hover:text-blue-700 md:p-0 dark:text-white md:dark:hover:text-blue-500 dark:hover:bg-gray-700 dark:hover:text-white md:dark:hover:bg-transparent">Pricing</a>
          </li>
          <li>
            <a href="#" class="block py-2 pl-3 pr-4 text-gray-900 rounded hover:bg-gray-100 md:hover:bg-transparent md:border-0 md:hover:text-blue-700 md:p-0 dark:text-white md:dark:hover:text-blue-500 dark:hover:bg-gray-700 dark:hover:text-white md:dark:hover:bg-transparent">Contact</a>
          </li> -->
        </ul>
      </div>
    </div>
  </nav>
  
  

<div class="p-8">

</div>

<div class="flex flex-row space-x-2">
    <div class="basis-3/4">
        <div class="p-8 pl-12">
            <div class="ml-2">
                <div class=" p-12 bg-white rounded-lg shadow-lg">
                    <p class="text-3xl" style="font-weight: 600;">Choosing the right database(RDBMS) for Data analyst?</p>
                    <br>
                    <div class="flex items-center gap-x-4 text-xs">
                        <time datetime="2022-11-27 10:21:19" class="text-gray-500">November 27, 2022</time>
                        
                        <a href="#" class="relative z-10 rounded-full bg-gray-50 px-3 py-1.5 font-medium text-gray-600 hover:bg-gray-100">
                            database
                        </a>
                        
                    </div>
                    
                        <div class="relative mt-8 flex items-center gap-x-4">
                            <img src="https://github.com/abdullium.png?size=200" alt="" class="h-10 w-10 rounded-full bg-gray-50">
                            <div class="text-sm leading-6">
                            <p class="font-semibold text-gray-900">
                                <a href="#">
                                <span class="absolute inset-0"></span>
                                Abdul Khan
                                </a>
                            </p>
                            <p class="text-gray-600">Data scientist</p>
                            </div>
                        </div>
                    
                    <br>
                    <article>
                        <blockquote>
<p><strong>Which database is best? The question, obviously, depends on what you want to use it for.</strong>
</p>
</blockquote>
<p><a href="https://raw.githubusercontent.com/Abdullium/Data_Analysis/main/Screenshot%202022-11-27%20134023.png"><img alt="" src="https://raw.githubusercontent.com/Abdullium/Data_Analysis/main/Screenshot%202022-11-27%20134023.png" /></a></p>
<p>I, like most Data analysts, want to use a database to warehouse, process, and manipulate data—and there&rsquo;s no shortage of thoughtful commentary outlining the types of databases I should prefer. But these evaluations, which typically discuss databases in terms of architecture, cost, scalability, and speed, rarely address one other key consideration: how hard is it for a beginner data analyst to write queries against these databases.<img alt="" src="https://raw.githubusercontent.com/Vertica/Vertica-Python/master/examples/vertica_error_rates.png" /></p>
<p>Relative to factors like processing speed and scalability, the essentials of a database&rsquo;s query language may seem trivial. Regardless of how hard it is to write a query against it?</p>
<p>When you work with a database day in and day out, the annoyances that hinder every quick project—how do I get the current time in Redshift? <code>NOW()</code>? <code>CURDATE()</code>? <code>CURDATE</code>? <code>SYSDATE</code>? <code>WHATDAYISIT?</code>—often slow you down more than a lower top speed.</p>
<p>I looked into the question as any analyst would—by using data. Data Analysts write thousands of queries in SQL using various RDBMS. My analysis focused on the eight most popular: MySQL, PostgreSQL, Redshift, SQL Server, BigQuery, Vertica, Hive, and Impala</p>
<hr />
<p><a href="https://images.ctfassets.net/fi0zmnwlsnja/110MlzPLetri6azOQ0AyhU/2c4f2845e52736f0cb8ce80b9eacb239/best-database-chart-4.png?w=1740&amp;h=724&amp;q=50&amp;fm=webp" title="im_3"><img alt="im_3" src="https://images.ctfassets.net/fi0zmnwlsnja/110MlzPLetri6azOQ0AyhU/2c4f2845e52736f0cb8ce80b9eacb239/best-database-chart-4.png?w=1740&amp;h=724&amp;q=50&amp;fm=webp" title="im_3" /></a>
Table of contents:</p>
<hr />
<ol>
<li>A basic measure of difficulty</li>
<li>Controlling for query complexity</li>
<li>Scale vs Speed</li>
<li>Flavour of SQL</li>
<li>Head-to-head comparisons</li>
<li>The winners</li>
</ol>
<h2>A basic measure of difficulty</h2>
<p>The most basic indicator that an analyst is having trouble with a query is when it fails. These error messages, (constantly) rejecting bad syntax, misnamed functions, or a misplaced comma, probably provide the truest indication of how much a language frustrates a Data analyst.</p>
<p>I started simple, looking at how often queries fail. As it turns out, Vertica and SQL Server have the highest error rates, and MySQL and Impala have the lowest. The chart below shows the error rates for each database.</p>
<p><a href="https://mode.com/blog-assets/images/post-images/best-database-chart-1.png" title="im_2"><img alt="im_2" src="https://mode.com/blog-assets/images/post-images/best-database-chart-1.png" title="im_2" /></a></p>
<p>Unfortunately for our wallets (Impala, MySQL, and Hive are all open-source and free, while Vertica, SQL Server, and BigQuery are decidedly not), rates like these are probably too crude to be conclusive.</p>
<p>People use databases for different things. Vertica and SQL Server are proprietary databases provided by major vendors, and most likely used by large businesses with deeper analytical budgets. The high error rates from these languages may come from a more ambitious use of the language rather than the language being “harder.”</p>
<hr />
<h2>Controlling for query complexity</h2>
<p>Can we then adjust for how complex a query is? Unfortunately, controlling for query complexity is hard.</p>
<p>Query length could be a decent proxy, but it&rsquo;s not perfect.
 <a href="https://mode.com/blog-assets/images/post-images/best-database-chart-2.png" title="im_4"><img alt="im_4" src="https://mode.com/blog-assets/images/post-images/best-database-chart-2.png" title="im_4" /></a></p>
<hr />
<p>An easy language may be easy because it&rsquo;s concise. Or, as anyone who&rsquo;s attempted to parse a string of seemingly random brackets, backslashes, and periods in a regular expression will tell you, a language may be hard because it&rsquo;s concise.</p>
<p>While there are clear differences in query lengths across different languages, the relationships between query length, query complexity, and language difficulty are all intertwined. Figuring out these relationships sounds even more daunting than parsing regex.</p>
<p>But we may be able to control for complexity in other ways. Queries often evolve over the course of an analysis. They start as simple explorations and become more complex as analysts add layers. You can see this evolution in the chart below, which shows how the median query doubles in length after 20 or so edits, and triples after 100 edits.</p>
<p><a href="https://mode.com/blog-assets/images/post-images/best-database-chart-3.png" title="im_5"><img alt="im_5" src="https://mode.com/blog-assets/images/post-images/best-database-chart-3.png" title="im_5" /></a></p>
<p>Rather than comparing queries of similar lengths, we could instead compare queries at the same stage in the analytical process. How often does the first query run result in an error? The fifth? The 20th?</p>
<p>The chart below shows the error rates for queries by the number of times analysts have edited them. After five or so runs, a few clear patterns emerge. PostgreSQL, MySQL, and Redshift have consistently low error rates. Impala, BigQuery, and SQL Server have high error rates. And as before, Vertica consistently outpaces the rest with the highest error rate.</p>
<p><a href="https://mode.com/blog-assets/images/post-images/best-database-chart-4.png" title="im_6"><img alt="im_6" src="https://mode.com/blog-assets/images/post-images/best-database-chart-4.png" title="im_6" /></a></p>
<h4>Scale vs. Speed</h4>
<p>When you need speed, consider Postgres: Under 1TB, Postgres is quite fast for loading and querying. Plus, it’s affordable. As you get closer to their limit of 6TB (inherited by Amazon RDS), your queries will slow down.</p>
<h4>Flavor of SQL</h4>
<p>Redshift is built on a variation of Postgres, and both support good ol’ SQL. Redshift doesn’t support every single data type and function that postgres does, but it’s much closer to the industry standard than BigQuery, which has its own flavor of SQL.</p>
<p>Unlike many other SQL-based systems, BigQuery uses the comma syntax to indicate table unions, not joins according to their docs. This means that without being careful regular SQL queries might error out or produce unexpected results. Therefore, many teams have trouble convincing their analysts to learn BigQuery’s SQL.</p>
<h2>Head-to-head comparisons</h2>
<p>Query complexity, however, isn&rsquo;t the only factor affecting error rates. If you&rsquo;ve seen me bulldoze through 15 syntax errors in a row, you know the skill of the analyst also matters.</p>
<p>Twenty percent of analysts using online compilers write queries against more than one type of database. Personally, I regularly use PostgreSQL and Pandas</p>
<p>These multi-lingual analysts offer us an opportunity. Among people who use different languages, which are they most comfortable with? Does an analyst who uses PostgreSQL and BigQuery tend to have higher error rates in one language or another? If we could pit SQL languages against each other (in what would surely be the nerdiest gladiator round), which one would win?</p>
<blockquote>
<p>I used a method of <strong>pairwise comparisons</strong> to aggregate together these head-to-head matchups:
</p>
</blockquote>
<ul>
<li>I found all the analysts who&rsquo;ve run a minimum of 10 queries per database for multiple databases.</li>
<li>I calculated the query error rates for each analyst for each database.</li>
<li>I averaged the differences in error rates for every database pair to construct the matrix below.</li>
</ul>
<p>The matrix shows the difference in error rates of the database on the top row compared to the database on the left. Here, a higher number is worse than a lower number. For example, the “20.2” at the intersection of Hive and BigQuery indicates that, among analysts who use both of those databases, the error rate tends to be 20.2% higher for Hive than BigQuery.</p>
<p><a href="https://mode.com/blog-assets/images/post-images/best-database-chart-5.png" title="im_7"><img alt="im_7" src="https://mode.com/blog-assets/images/post-images/best-database-chart-5.png" title="im_7" /></a></p>
<p>The total score line on the bottom sums the differences for each database. The result provides a similar conclusion to the error-by-run analysis: MySQL and PostgreSQL are the easiest versions of SQL to write. Redshift also jumps up a couple of spots, from the fourth easiest to the second easiest.</p>
<p>Vertica gains the most ground. It moves from being the most difficult language to somewhere near the middle of the pack, beating out SQL Server and Hive. This suggests that Vertica&rsquo;s high error rate may be more indicative of the type of analyst that uses it than it is of the language itself.</p>
<h2>The winners</h2>
<p>Overall, these numbers point to MySQL and PostgreSQL as the easiest versions of SQL to write. Intuitively, this makes sense. Among the eight languages analyzed, these two are the most widely used in online SQL compiler likes <strong>(</strong> <strong>SQL Fiddle,</strong> <strong>SQL Mode,</strong> <strong>SQL Online,</strong> <strong>and</strong> <strong>Hackkerank</strong> <strong>)</strong> Unfortunately for analysts, they&rsquo;re also poorer in features—and often slower—than languages like Vertica and SQL Server.</p>

                        <script src="https://utteranc.es/client.js"
        repo="pythonkitchen/blog-comments"
        issue-term="pathname"
        theme="github-light"
        crossorigin="anonymous"
        async>
</script>
                    </article>
                
                  </div>
                
            </div>
        </div>
        
    </div>
    <div class="basis-1/4"></div>
  </div>




<script>hljs.highlightAll();</script>




</body>
</html>