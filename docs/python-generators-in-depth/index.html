<!doctype html>
<html>
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    a {
	word-wrap: break-word !important;
}
  </style>
  
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/default.min.css">
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/highlight.min.js"></script>

<!-- and it's easy to individually load additional languages -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/languages/python.min.js"></script>

<link rel="stylesheet" href="/post.css"> 

</head>
<body class="bg-gray-50">

<nav class="bg-white border-gray-200 dark:bg-gray-900">
    <div class="max-w-screen-xl flex flex-wrap items-center justify-between mx-auto p-4">
      <a href="/" class="flex items-center">
          <img src="https://www.pythonkitchen.com/wp-content/uploads/2022/11/cropped-p3-50x50.png" class="h-8 mr-3" alt="PythonKitchen Logo" />
          <span class="self-center text-2xl font-semibold whitespace-nowrap dark:text-white">PythonKitchen</span>
      </a>
      <button data-collapse-toggle="navbar-default" type="button" class="inline-flex items-center p-2 w-10 h-10 justify-center text-sm text-gray-500 rounded-lg md:hidden hover:bg-gray-100 focus:outline-none focus:ring-2 focus:ring-gray-200 dark:text-gray-400 dark:hover:bg-gray-700 dark:focus:ring-gray-600" aria-controls="navbar-default" aria-expanded="false">
          <span class="sr-only">Open main menu</span>
          <svg class="w-5 h-5" aria-hidden="true" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 17 14">
              <path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M1 1h15M1 7h15M1 13h15"/>
          </svg>
      </button>
      <div class="hidden w-full md:block md:w-auto" id="navbar-default">
        <ul class="font-medium flex flex-col p-4 md:p-0 mt-4 border border-gray-100 rounded-lg bg-gray-50 md:flex-row md:space-x-8 md:mt-0 md:border-0 md:bg-white dark:bg-gray-800 md:dark:bg-gray-900 dark:border-gray-700">
          <li>
            <a href="/" 
            class="block py-2 pl-3 pr-4 text-white bg-blue-700 rounded md:bg-transparent md:text-blue-700 md:p-0 dark:text-white md:dark:text-blue-500" aria-current="page">
            Home</a>
          </li>
          <li>
            <a href="https://github.com/pythonkitchen/pythonkitchen/tree/source/data/posts" class="block py-2 pl-3 pr-4 text-gray-900 rounded hover:bg-gray-100 md:hover:bg-transparent md:border-0 md:hover:text-blue-700 md:p-0 dark:text-white md:dark:hover:text-blue-500 dark:hover:bg-gray-700 dark:hover:text-white md:dark:hover:bg-transparent">
              Write</a>
          </li>
          <li>
            <a href="https://forms.gle/gf1p1Aitw9M9m8Zy5" class="block py-2 pl-3 pr-4 text-gray-900 rounded hover:bg-gray-100 md:hover:bg-transparent md:border-0 md:hover:text-blue-700 md:p-0 dark:text-white md:dark:hover:text-blue-500 dark:hover:bg-gray-700 dark:hover:text-white md:dark:hover:bg-transparent">
              Contact</a>
          </li>
          <!-- <li>
            <a href="#" class="block py-2 pl-3 pr-4 text-gray-900 rounded hover:bg-gray-100 md:hover:bg-transparent md:border-0 md:hover:text-blue-700 md:p-0 dark:text-white md:dark:hover:text-blue-500 dark:hover:bg-gray-700 dark:hover:text-white md:dark:hover:bg-transparent">Pricing</a>
          </li>
          <li>
            <a href="#" class="block py-2 pl-3 pr-4 text-gray-900 rounded hover:bg-gray-100 md:hover:bg-transparent md:border-0 md:hover:text-blue-700 md:p-0 dark:text-white md:dark:hover:text-blue-500 dark:hover:bg-gray-700 dark:hover:text-white md:dark:hover:bg-transparent">Contact</a>
          </li> -->
        </ul>
      </div>
    </div>
  </nav>
  
  

<div class="p-8">

</div>

<div class="flex flex-row space-x-2">
    <div class="basis-3/4">
        <div class="p-8 pl-12">
            <div class="ml-2">
                <div class=" p-12 bg-white rounded-lg shadow-lg">
                    <p class="text-3xl" style="font-weight: 600;">Python Generators:  The In-depth Article You've Always Wanted</p>
                    <br>
                    <div class="flex items-center gap-x-4 text-xs">
                        <time datetime="2020-12-10 06:37:27" class="text-gray-500">December 10, 2020</time>
                        
                        <a href="#" class="relative z-10 rounded-full bg-gray-50 px-3 py-1.5 font-medium text-gray-600 hover:bg-gray-100">
                            generators
                        </a>
                        
                    </div>
                    
                        <div class="relative mt-8 flex items-center gap-x-4">
                            <img src="https://github.com/Abdur-rahmaanJ.png?size=200" alt="" class="h-10 w-10 rounded-full bg-gray-50">
                            <div class="text-sm leading-6">
                            <p class="font-semibold text-gray-900">
                                <a href="#">
                                <span class="absolute inset-0"></span>
                                Abdur-Rahmaan Janhangeer
                                </a>
                            </p>
                            <p class="text-gray-600">Chef</p>
                            </div>
                        </div>
                    
                    <br>
                    <article>
                        <h1>Table of contents</h1>
<ul>
<li>Why were Python generators introduced?</li>
<li>How do Python Generators differ from normal functions?</li>
<li>Execution flow</li>
<li>Immediate usefulness</li>
<li>next and for loops</li>
<li>Generators introduced for memory saving</li>
<li>Generators for tasks</li>
<li>The send method</li>
<li>Deriving send</li>
<li>What is yield from</li>
<li>The last part</li>
<li>The limit of generators: Infinity and Beyond</li>
</ul>
<p>In Python, generators form part of the intermediate topics. Since it differs from conventional functions, beginners have to take sometimes to wrap their head around it. This article presents materials that will be useful both for beginners and advanced programmers. It attempts to give enough to understand generators in depth but don&rsquo;t cover all use cases.</p>
<h3>Why were Python generators introduced?</h3>
<p>Before we present generators and it&rsquo;s syntax, it&rsquo;s important to know why in the first place were generators introduced. The yield keyword does not mean generators. One has to understand the concept behind. The original PEP introduced &ldquo;the concept of generators to Python, as well as a new statement used in conjunction with them, the yield statement&rdquo; [1].</p>
<p>The general use case of generators is as follows:</p>
<blockquote>
<p>When a producer function has a hard enough job that it requires maintaining state between values produced, [1]
</p>
</blockquote>
<p>And more explicitly</p>
<blockquote>
<p>provide a kind of function that can return an intermediate result (&ldquo;the next value&rdquo;) to its caller, but maintaining the function&rsquo;s local state so that the function can be resumed again right where it left off. [1]
</p>
</blockquote>
<p>So we understand that a new kind of functions was needed that:</p>
<ul>
<li>
<ol>
<li>return intermediate values</li>
</ol>
</li>
<li>
<ol>
<li>save the state of functions</li>
</ol>
</li>
</ul>
<h3>How do Python Generators differ from normal functions?</h3>
<p>Compared to normal functions, once you return from a function, you can go back to return more values. A normal function in contrast, once you return from it, there is no going back.</p>
<p>Normal function:</p>
<pre><code class="language-python">def x():
    print('abc')
    return 
    print('def') # not reached
x()

</code></pre>
<p>In the above example, <code>def</code> will not be printed as the function exited before. Let&rsquo;s examine a basic generator example:</p>
<pre><code class="language-python">def x():
  a = 0
  while 1:
    yield a

    a += 1

z = x()

print(z)
print(next(z))
print(next(z))

</code></pre>
<pre><code class="language-python">&lt;generator object x at 0x01ACB760&gt;
0
1

</code></pre>
<p>From the example above, once we called next, it returned a value. <strong>The purpose of next is to go to the next yield statement</strong>. When we called next the first time, it went to the next yield since the beginning which is when <code>a</code> was initially at 0.</p>
<p>The second call of next started executing <code>a += 1</code> and went to the beginning of the loop where it encountered a yield statement and returned <code>a</code> with the updated value.</p>
<p>By <code>a</code> being updated we see that even when the function was exited the first time, when the program went back into it, it continued on the previous state when <code>a</code> was 0. This accomplishes the two aims of being able to resume functions and saving the previous state.</p>
<p>To understand it better, here are some more names that were proposed instead of yield [1] but were eventually rejected:</p>
<ul>
<li>return 3 and continue</li>
<li>return and continue 3</li>
<li>return generating 3</li>
<li>continue return 3</li>
</ul>
<p>Guido gives a summary of generators [1]:</p>
<blockquote>
<p>In practice (how you think about them), generators are functions, but with the twist that they&rsquo;re resumable.
</p>
</blockquote>
<h3>Execution flow</h3>
<p>The following snippet gives us an idea about the execution:</p>
<pre><code class="language-python">def x():
  print('started')
  while 1:
    print('before yield')
    yield
    print('after yield')


z = x()

next(z)
print('-- 2nd call')
next(z)

</code></pre>
<pre><code class="language-python">started
before yield
-- 2nd call
after yield
before yield

</code></pre>
<p>From it we confirm that the first call to next executes everything in the function until the first yield statement. We did not return any values but used yield purely to control the flow of execution in the same sense of return.</p>
<p>Yield needs not to be in infinite loops, you can use several at once in the same function body:</p>
<pre><code class="language-python">def x():
  print('start')
  yield 
  print('after 1st yield')
  yield
  print('after 2nd yield')

z = x()
next(z)
next(z)
next(z)

</code></pre>
<pre><code class="language-python">start
after 1st yield
after 2nd yield
Traceback (most recent call last):
  File &quot;lab.py&quot;, line 11, in &lt;module&gt;
    next(z)
StopIteration

</code></pre>
<p>In case you called next more than there is yield statements, generator functions raise the <code>StopIteration</code>. In case you want to auto-handle <code>StopIteration</code> until there are no more left, use &hellip; a for loop:</p>
<pre><code class="language-python">def x():
  print('start')
  yield 
  print('after 1st yield')
  yield
  print('after 2nd yield')

z = x()
for _ in z:
  pass


</code></pre>
<p>In case you return a value, the loop variable will be equal to that value:</p>
<pre><code class="language-python">def x():
  print('start')
  yield 1
  print('after 1st yield')
  yield 2
  print('after 2nd yield')

z = x()
for _ in z:
  print(_)

</code></pre>
<pre><code class="language-python">start
1
after 1st yield
2
after 2nd yield

</code></pre>
<h3>Immediate usefulness</h3>
<p>Since we saw that we can use yield with an infinite loop, this is extremely powerful. We can break infinity in steps. Consider this:</p>
<pre><code class="language-python">def odd_till(number):
  n = 1
  while n &lt; number:
    yield n
    n += 2

for odd_num in odd_till(10):
  print(odd_num)

</code></pre>
<p>We yield one number and the function exits, the for loop calls it again. It yields one number and exits. And so on. It goes about it in micro steps. The operations completed in one cycle is is just an increment <code>n += 2</code> and a check <code>n &lt; number</code>.</p>
<hr />
<blockquote>
<p><code>odd_till(10)</code> or <code>odd_till(10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000)</code> don&rsquo;t not cause memory errors
</p>
</blockquote>
<h3>next and for loops</h3>
<p>Two things might puzzle you:</p>
<ul>
<li>why was next used?</li>
<li>how can a function with 2 yields work when a for loop is used with it?</li>
</ul>
<p>The answer lies in in the fact that generators implement the iterator protocols, the same one used by lists. Here is a class customised to act as a generator [7]:</p>
<pre><code class="language-python"># Using the generator pattern (an iterable)
class firstn(object):
    def __init__(self, n):
        self.n = n
        self.num = 0

    def __iter__(self):
        return self

    # Python 3 compatibility
    def __next__(self):
        return self.next()

    def next(self):
        if self.num &lt; self.n:
            cur, self.num = self.num, self.num+1
            return cur
        else:
            raise StopIteration()

sum_of_first_n = sum(firstn(1000000))

</code></pre>
<h3>Generators introduced for memory saving</h3>
<p>Consider a list comprehension:</p>
<pre><code class="language-python">sum([x*x for x in range(10)])

</code></pre>
<p>A generator expression is much, much more efficicent [2]:</p>
<pre><code class="language-python">sum(x*x for x in range(10))

</code></pre>
<p>This was the second addition in the generator story.</p>
<h3>Generators for tasks</h3>
<p>Lets modify our two functions with print</p>
<pre><code class="language-python">def odd_till(number):
  n = 1
  while n &lt; number:
    print('odd_till {} currently: {}'.format(number, n))
    yield n
    n += 2

def even_till(number):
  n = 0
  while n &lt; number:
    print('even_till {} currently: {}'.format(number, n))
    yield n
    n += 2

</code></pre>
<p>Lets have a class to run functions</p>
<pre><code class="language-python">from collections import deque

class RunFunc:
  def __init__(self):
    self._queue = deque()

  def add_func(self, func):
    self._queue.append(func)

  def run(self):
    while self._queue:
      func = self._queue.popleft()
      try:
        next(func)
        self._queue.append(func)
      except StopIteration:
        pass

</code></pre>
<p>usage</p>
<pre><code class="language-python">func_runner = RunFunc()

func_runner.add_func(odd_till(5))
func_runner.add_func(even_till(4))
func_runner.add_func(odd_till(6))
func_runner.run()

</code></pre>
<hr />
<p>output</p>
<pre><code class="language-python">odd_till 5 currently: 1
even_till 4 currently: 0
odd_till 6 currently: 1
odd_till 5 currently: 3
even_till 4 currently: 2
odd_till 6 currently: 3
odd_till 6 currently: 5

</code></pre>
<p>If we rename the same thing we get a mini task scheduler [4]</p>
<pre><code class="language-python">from collections import deque

class TaskScheduler:
  def __init__(self):
    self._queue = deque()

  def add_task(self, task):
    self._queue.append(task)

  def run(self):
    while self._queue:
      task = self._queue.popleft()
      try:
        next(task)
        self._queue.append(task)
      except StopIteration:
        pass

</code></pre>
<p>usage</p>
<pre><code class="language-python">scheduler = TaskScheduler()

scheduler.add_task(odd_till(5))
scheduler.add_task(even_till(4))
scheduler.add_task(odd_till(6))
scheduler.run()

</code></pre>
<p>Just a point of note, why do we remove a task (popleft) and readd it (append)?</p>
<pre><code class="language-python">      task = self._queue.popleft()
      try:
        next(task)
        self._queue.append(task)
      except StopIteration:
        pass

</code></pre>
<p>That&rsquo;s because if it was finished (exception raised) well and good, it will go straight to the except block. Else the .append will get executed.</p>
<p>In other words if task terminated, don&rsquo;t add it back else add it back.</p>
<h3>The send method</h3>
<p>Generators support a way of sending values to generators</p>
<pre><code class="language-python">def times2():
    while True:
        val = yield
        yield val * 2

z = times2()


next(z)
print(z.send(1))
next(z)
print(z.send(2))
next(z)
print(z.send(3))

</code></pre>
<pre><code class="language-python">2
4
6

</code></pre>
<p>This was an important addition. This passage explains why was send introduced and why it&rsquo;s important in asyncio [6]:</p>
<blockquote>
<p>Python&rsquo;s generator functions are almost coroutines &ndash; but not quite &ndash; in that they allow pausing execution to produce a value, but do not provide for values or exceptions to be passed in when execution resumes &hellip; However, if it were possible to pass values or exceptions into a generator at the point where it was suspended, a simple co-routine scheduler or trampoline function would let coroutines call each other without blocking &ndash; a tremendous boon for asynchronous applications. Such applications could then write co-routines to do non-blocking socket I/O by yielding control to an I/O scheduler until data has been sent or becomes available. Meanwhile, code that performs the I/O would simply do something like this: <code>data = (yield nonblocking_read(my_socket, nbytes))</code> in order to pause execution until the <code>nonblocking_read()</code> coroutine produced a value.
</p>
</blockquote>
<p>yield was fundamentally changed with the addition of send.</p>
<ul>
<li>
<ol>
<li>Redefine yield to be an expression, rather than a statement. The current yield statement would become a yield expression whose value is thrown away. A yield expression&rsquo;s value is None whenever the generator is resumed by a normal next() call.</li>
</ol>
</li>
<li>
<ol>
<li>Add a new send() method for generator-iterators, which resumes the generator and sends a value that becomes the result of the current yield-expression. The send() method returns the next value yielded by the generator, or raises StopIteration if the generator exits without yielding another value.</li>
</ol>
</li>
</ul>
<p>send(None) can also be used instead of the first next()</p>
<h3>Deriving send</h3>
<p>How do we derive send? A tricky question indeed. Here&rsquo;s a mini snippet showing how [4]</p>
<pre><code class="language-python">from collections import deque

class ActorScheduler:
  def __init__(self):
    self._actors = { } # Mapping of names to actors
    self._msg_queue = deque() # Message queue

  def new_actor(self, name, actor):
    '''
    Admit a newly started actor to the scheduler and give it a name
    '''
    self._msg_queue.append((actor,None))
    self._actors[name] = actor

  def send(self, name, msg):
    '''
    Send a message to a named actor
    '''
    actor = self._actors.get(name)
    if actor:
      self._msg_queue.append((actor,msg))

  def run(self):
    '''
    Run as long as there are pending messages.
    '''
    while self._msg_queue:
      actor, msg = self._msg_queue.popleft()
      try:
        actor.send(msg)
      except StopIteration:
        pass

# Example use
if __name__ == '__main__':
  def printer():
    while True:
      msg = yield
      print('Got:', msg)

  def counter(sched):
    while True:
    # Receive the current count
      n = yield
      if n == 0:
        break
      # Send to the printer task
      sched.send('printer', n)
      # Send the next count to the counter task (recursive)
      sched.send('counter', n-1)


  sched = ActorScheduler()
  # Create the initial actors
  sched.new_actor('printer', printer())
  sched.new_actor('counter', counter(sched))
  # Send an initial message to the counter to initiate
  sched.send('counter', 100)
  sched.run()

</code></pre>
<p>The above can be expanded with more areas like ready, ready to read, ready to write and writing the appropriate code to switch between the areas and &hellip; you have a concurrent app. This is the basics of an operating system [4]. Using <code>sched.send</code> allows to have a loop beyond the recursion limit of python. The recursion limit is <code>import sys; sys.getrecursionlimit()</code> usually 1000. try <code>sched.send('counter', 1001)</code>.</p>
<h3>What is yield from?</h3>
<p>Consider the following code:</p>
<pre><code class="language-python">def gen_alph():
  for a in 'abc':
    yield a

def gen_nums():
  for n in '123':
    yield n


def gen_data():
  yield from gen_alph()
  yield from gen_nums()


for _ in gen_data():
  print(_)

</code></pre>
<pre><code class="language-python">a
b
c
1
2
3

</code></pre>
<p>It behaves exactly as if the alphabet and number loops with their respective yields was inside gen_data.</p>
<p>&ldquo;yield from is to generators as calls are to functions&rdquo; as Brett Cannon puts it [8]</p>
<h3>The last part</h3>
<p>Generators have a close method, caught by a GeneratorExit exception:</p>
<pre><code class="language-python">def gen_alph():
  try:
    for a in 'abc':
      yield a
  except GeneratorExit:
      print('Generator exited')

z = gen_alph()
next(z)
z.close()

</code></pre>
<pre><code class="language-python">Generator exited

</code></pre>
<p>They also have a throw method to catch errors:</p>
<pre><code class="language-python">def gen_alph():
  try:
    for a in 'abc':
      yield a
  except GeneratorExit:
      print('Generator exited')
  except Exception:
    yield 'error occured'

z = gen_alph()
next(z)
print(z.throw(Exception))

</code></pre>
<pre><code class="language-python">error occured

</code></pre>
<h3>The limit of generators: Infinity and Beyond</h3>
<p>If you really want the best of Python generators the internet can give you
copied over and over by Python sites, see David Beazley&rsquo;s 3 parts series:</p>
<ul>
<li><a href="http://www.dabeaz.com/generators">Generator Tricks for Systems Programmers</a></li>
<li><a href="http://www.dabeaz.com/coroutines/">A Curious Course on Coroutines and Concurrency</a></li>
<li><a href="http://www.dabeaz.com/finalgenerator/">Generators: The Final Frontier</a></li>
</ul>
<p>It also includes lots of use cases.</p>
<p><em>Abdur-Rahmaan Janhangeer is an organising member of the <a href="https://www.pymug.com">Python Mauritius User Group</a> (PyMUG), <a href="https://www.flaskcon.com">FlaskCon</a> and maintains <a href="https://www.pythonkitchen.com">pythonkitchen.com</a>. The present article is the continuation of his talk about deriving asyncio</em></p>
<h3>References</h3>
<p>[1] https://www.python.org/dev/peps/pep-0255/
[2] https://www.python.org/dev/peps/pep-0289/
[3] https://dev.to/abdurrahmaanj/add-superpowers-to-your-python-lists-using-this-feature-24nf
[4] Python Cookbook, David Beazley
[5] https://docs.python.org/3/library/asyncio-task.html
[6] https://www.python.org/dev/peps/pep-0342/
[7] https://wiki.python.org/moin/Generators
[8] Brett Cannon: Python 3.3: Trust Me, It&rsquo;s Better Than Python 2.7</p>

                        <script src="https://utteranc.es/client.js"
        repo="pythonkitchen/blog-comments"
        issue-term="pathname"
        theme="github-light"
        crossorigin="anonymous"
        async>
</script>
                    </article>
                
                  </div>
                
            </div>
        </div>
        
    </div>
    <div class="basis-1/4"></div>
  </div>




<script>hljs.highlightAll();</script>




</body>
</html>